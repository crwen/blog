---
title: Redis 复习
date: 2021-04-05 20:26:39
categories: Redis
tags: Redis
---

本文是对 Redis 知识点的总结，不定期更新

<!-- more -->

# Redis

## 特性

**Redis 为什么块**

- 单线程，大部分操作在内存上完成
- 事件模型，基于多路复用模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

## 数据类型

**string**

```sh
set hello world
get hello
del hello
```

**list**

```sh
rpush list-key item
rpush list-key item2
rpush list-key item

lrange list-key 0 -1 # item item2 item
lindex list-key 1 # item2

lpop list-key # item

lrange list-key 0 -1 # item2 item
```

**set**

```sh
sadd set-key item
sadd set-key item2
sadd set-key item3
sadd set-key item

smembers set-key # item item2 item3
sismember set-key item # 1

srem set-key item2

smembers set-key # item item3
```

**hash**

```sh
hset hash-key sub-key1 value1
hset hash-key sub-key2 value2
hset hash-key sub-key1 value1

hgetall hash-key # sub-key1 value1  sub-key2 value2

hdel hash-key sub-key2

hget hash-key sub-key1 # value1
```

**zset**

```sh
zadd zset-key 728 member1
zadd zset-key 982 member0
zadd zset-key 982 member0

zrange zset-key 0 -1 withscores # member1 728   member0 982

zrangebyscore zset-key 0 800 withscores # member1 728

zrem zset-key member1
```

## 数据结构

### 链表

```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
}
typeDef struct list {
    listNode *head;
    listNode *tail;
    unsigned long len; // 链表包含元素数量
    void *(*dup)(void *ptr);// 节点值复制函数
    void (*free)(void *ptr);// 节点值释放函数
    int (*match)(void *ptr, void *key);//节点值对比函数
}
```

Redis 中的链表是一个**双向无环链表**，获取前驱节点、后继节点、链表长度的时间复杂度都是 O(1)

### 字典

dictht 是一个散列表结构，使用**拉链法**解决哈希冲突。

```c
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; 
    unsigned long iterators; 
} dict;
```

<img src="https://cdn.jsdelivr.net/gh/crwen/img/blog/redis_dict.png" style="zoom:67%;" />

rehash 操作不是一次性完成，而是采用**渐进方式**，这是为了**避免一次性执行过多的 rehash 操作给服务器带来过大的负担**。

渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。

在 rehash 期间，**每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。在rehash 期间，添加到字典中的键值对会被保持到 ht[1] 中。**

采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。

### 跳表

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" alt="img" style="zoom:67%;" />

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" alt="img" style="zoom:67%;" />

与红黑树等平衡树相比，跳跃表具有以下优点：

- 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
- 更容易实现；
- 支持无锁操作。

### 压缩列表

## 键的过期时间

Redis 可以通过 `expire` 或者 `pexpire` 命令为每个键设置过期时间，当键过期时，会自动删除该键。

> `setex` 命令可以在设置一个字符串键的同时为键设置过期时间，但是只能用于字符串

redisDb 结构中有一个 expires 过期字典，保存了数据库中所有键的过期时间。过期字典的键是一个指针，指向间空间中的键对象；过期字典的值是一个 long long 类型的整数，保存了**键所指向的数据库键的过期时间**

<img src="https://cdn.jsdelivr.net/gh/crwen/img/blog/expire_dict.png" style="zoom:50%;" />

### 过期键删除策略

**1. 定时删除**

通过使用定时器，定时删除删除过期键。这种方式可以保证过期键会尽可能快地被删除，并释放过期键所占用地内存，对内存是最友好的。

定期删除对 CPU 时间最不友好的，因为在过期键比较多的情况下，删除过期键可能占用相当一部分 CPU 时间；而且 Redis 中的事件事件的实现是无序列表，查找时间复杂度为 O(n)。

**2.  惰性删除**

程序在取出键时才对键进行过期检查，这样可以保证删除过期键的操作只会在非做不可的情况下进行，对 CPU 事件来说时最友好的。

惰性删除对内存最不友好，因为内存中可能存在很多过期键，但是得不到释放

**3. 定期删除**

定期删除时定时删除和定期删除的一种这种，它每隔一段时间执行依次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少 CPU 的影响。

**3. Redis 的实现方式**

Redis 将配合使用**定期删除**和**惰性删除**策略，在合理使用 CPU 时间和避免浪费内存空间之间取得平衡。

- 所有**读写数据库的 Redis 命令在执行之前都会调用** `expireIfNeeded` 函数对输入键进行检查，如果键已经过期，就删除。
- 每当 Redis **周期性操作时，调用** `activeExpireCycle` 函数，在规定时间内，分多次遍历各个数据库，从过期字典中随机检查一部分键的过期时间，并删除过期键

**RDB对过期键的策略**

在执行 `SAVE` 或 `BGSAVE` 时，会对键进行检查，排除已过期的键。

载入 RDB 文件时

- 主服务器模式，会对保存的键进行检查，忽略过期键。
- 从服务器模式，载入所有数据。但是数据同步时，从服务器数据会被清空

**AOF对过期键的策略**

- 键过期当时没被删除，不影响

- 键过期被删除，向 AOF 中追加一条 `DEL` 命令来显示记录该键已被删除

AOF 重写时，对键进行检查，已过期的键不会被保存到重写的 AOF 中。

## 持久化

Redis 有两种持久化方式，分别是 RDB 和 AOF(Append Only File)

### RDB

RDB 会将某一时刻的数据库状态以文件的形式写入到磁盘中。

有三种触发 RDB 的方法，分别是

- `SAVE` 同步命令：`SAVE` 命令会**阻塞** Redis 服务器进程，直到 RDB 文件创建完毕为止。这时客户端发送的所有命令都会被阻塞
- `BGSAVE` 异步命令：`BGSAVE` 命令回 `fork` 出一个进程用于创建 RDB  文件，此时读命令可以正常执行，**写命令会生成该数据的副本**，然后子进程会把这个副本数据写入 RDB 文件
- 自动触发：在配置文件中配置，比如 `save 60 10000`，Redis 服务器默认每隔 100ms 周期性地执行操作函数 `serverCron`，，当满足条件时，会使用 `BGSAVE` 生成 RDB 文件。修改次数与时间由 `dirty` 与 `lastsave` 属性进行维护

### AOF

 AOF 持久化功能的实现可以分为三个步骤：命令追加 (append)、文件写入、文件同步 (sync)

- **命令追加**：服务器在执行完一个命令后，将被**执行的写命令追加到服务器状态的 `aof_buf` 缓冲区的末尾**。

- **文件写入与同步**：服务器在每次结束一个事件循环之前，调用 `flushAppendOnlyFile` 函数，将缓冲区中的内容写入和保存到 AOF 文件中。

|   选项   |         同步频率         |
| :------: | :----------------------: |
|  always  |     每个写命令都同步     |
| everysec |       每秒同步一次       |
|    no    | 让操作系统来决定何时同步 |

**AOF 重写**

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

AOF 重写时**先从数据库中读取键的值，然后用一条命令去记录键值对**，代替之前记录这个键值对的多条命令。

Redis 将 AOF 重写操作放到**子进程**中执行，子进程带有服务器进程的数据副本，可以在避免使用所的情况下保证数据的安全。

在子进程重写期间，**写命令会写入到发送给 AOF 缓冲区和重写缓冲区**。当 AOF 重写完成后，会将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中。

<img src="https://cdn.jsdelivr.net/gh/crwen/img/blog/AOF_rewrite.png" style="zoom:50%;" />

### 混合使用 AOF 与 RDB

Redis 4.0 后开始支持混合使用 AOF 与 RDB。在 RDB 备份期间，使用 AOF 记录写命令，在下一次 RDB 时，清空 AOF 文件。

## 事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

```sh
watch key1 key2 # 监视若干个 key，如果在事务执行前，被监视的 key 被其他命令改动，则事务被打断（类似乐观锁）
multi # 标记一个事务块的开始
#...
# discard # 取消事务，放弃事务块中的所有事务
# unwatch # 取消 watch 对所有 key 的监控
exec # 执行所有事务块的命令
```

## 事件

Redis 服务器是一个事件驱动程序。

### 文件事件

服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。

Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" alt="img" style="zoom:67%;" />

### 时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

时间事件又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次；
- 周期性事件：是让一段程序每隔指定时间就执行一次。

Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

## 复制

通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主主复制。

```redis
SLAVEOF 127.0.0.1 6379 // Redis 5.0 之前
REPLICAOF 127.0.0.1 6379
```

### 连接过程

新版本的 Redis 采用 `PSYNC` 命令来实现复制功能。`PSYNC` 命令有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式。

### **完整重同步**

- **同步**

1. 从服务器向主服务器发送 `PSYNC` 命令
2. 收到 `PSYNC` 的主服务器执行 `BGSAVE` 命令，在后台生成 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 主服务器 `BGSAVE` 命令执行完毕，将 RDB 文件发送给从服务器
4. 从服务器接收并载入 RDB 文件，更新自己数据库状态
5. 主服务器将缓冲区中的写命令发送给从服务器，从服务器执行这些写命令，从而达到主从一致

- **命令传播**

  主服务器将执行的写命令发送给从服务器，并将写命令复制到积压缓冲区

**部分重同步**

部分重同步用于处理断线后重复制的情况。因为主从服务器保存的数据大部分都是相同的，所以没有必要重新进行完整重同步。为了解决这个问题，Redis 2.8 开始支持部分重同步。部分重同步中，**主服务器可以将从服务器连接断开期间执行的写命令发送给从服务器**

部分重同步功能由三个部分构成：

- **服务器运行 ID**：每个服务器都由自己的运行 ID，当从服务器初次复制时，从服务器会保存主服务器 ID。当从服务器断线重连后，向主服务器发送之前保存的 ID，如果 ID 与主服务器相同，说明是断线重连，否则进行完整重同步。
- **主服务器的复制积压缓冲区**：是一个固定大小的队列。复制积压缓冲区保存着最近传播的写命令，并且记录每个字节相应的复制偏移量。
- **主服务器的复制偏移量和从服务器的复制偏移量**：主从服务器会维持一个复制偏移量。当从服务器重连时，向主服务器发送复制偏移量 offset，如果复制积压缓冲区中还保持着 offset + 1 的数据，进行部分重同步。否则进行执行完整重同步。

### 主从链

一次全量复制中，对于主库来说，需要完成两个耗时操作：生成 RDB 文件和传输 RDB 文件。如果从库数量很多，就会导致主库忙于 fork 子进程生成 RDB 文件和传输 RDB 文件。因此可以采用 主-从-从 模式，将主库生成的 RDB 和传输 RDB 的压力，以级联的方式分散到从库上

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" alt="img" style="zoom: 50%;" />

### 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令 `REPLCONF ACK <replication_offset>`

这个命令主要有三个作用：

- **检测主从服务器的网络状态**：如果主服务器超过一秒没有收到来自从服务器的 `REPLCONF ACK` 命令，就说明主从之间的连接出现了问题。
- **辅助实现 `min-slaves` 选项**：防止主服务器在不安全的情况下执行功能写命令
- **检测命令丢失**：传播的命令可能会丢失，使用心跳检测可以可以发送命令的丢失。

## Sentinel

Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。可以在配置文件中配置如下信息

```conf
sentinel monitor <master-name> <ip> <redis-port> <quorum> 
```

Sentinel 主要执行三个任务：监控、选主和通知

**1. 监控**

监控是指哨兵进程在运行时，**周期性（每秒一次）地给所有主从库发送 PING 命令，检测他们是否仍然在线**。如果没有得到响应，就会将其设置为**主观下线**状态。

但是判断为主观下线不能说明真的下线，因为还有误判的可能。**当一定数量的哨兵都判断该服务器处于下线状态后，会将其设置为客观下线状态。**

**2. 选主**

当主服务器被判定为客观下线后，就需要选择新的主库。选主包含两部分：选择主 Sentinel 和选择主服务器

**leader 选举**

当一个主服务器被判断为客观下线时，这个哨兵就可以给其他哨兵发送命令，要求其他哨兵将自己设置为 leader。一个哨兵只能将一个哨兵设置为 leader，**当一个 Sentinel 获得半数以上的投票后，就成为 leader 哨兵**。

如果在给定时限内，没有选举出 leader，就会暂停一段时间，重新开始选举

**选择主服务器**

leader Sentinel 会将已下线主服务器的所有从服务器保存到一个列表中，然后按照以下规则选择主服务器

1. 删除列表中下线或短线的从服务器
2. 删除列表中最近 5s 没有回复过领头 Sentinel 的 INFO 命令的从服务器，保证剩余从服务器都是最近成功进行过通信的
3. 删除与已下线主服务器连接断开超过 `down-after-milliseconds * 10` 毫秒的服务器，保证从服务器没有过早地断开连接，即数据都是比较新的
4. 选择优先级最高的服务器
5. 选择偏移量最大的服务器
6. 选择运行 ID 最小的服务器

**3. 通知**

当新的主服务器出现后，领头 Sentinel 会让已下线的主服务器属下的所有从服务器去复制新的主服务器，并将就的主服务器设置为从服务器。

## 集群

一个 Redis 集群通常由多个节点组成，可以通过 `CLUSTER MEET` 命令让节点进行握手，握手成功时，节点就会将 ip 和 port 指定的节点添加到节点所在集群中。

```redis
CLUSTER MEET 127.0.0.1 6379
```

### 分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

## 使用场景

**1. 计数器**

**2. 缓存**

**3. 消息队列**

**4. 会话缓存**

**5. 分布式锁实现**

**6. 其他**



## 应用问题

### 数据一致性

**数据一致性**：缓存中有数据，则缓存中的数据需要与数据库中的相同；缓存没有数据，数据库中的值必须是最新值。

- 先写数据库，再删缓存：
  - 如果写数据库成功，删除缓存失败，会读取到旧值
  - 如果在写数据库后，删缓存前读取数据，会读取到旧值。
- 先删缓存，再写数据库：
  - 如果删除缓存成功，写数据库失败，会造成新值丢失，读取到旧值。
  - 如果在删除缓存后，写数据库前读取数据，发现缓存缺失，读数据库旧值，并将旧值写入缓存。（~~延迟双删，更新完数据库后，sleep之后再删一次缓存~~、加锁，分布式锁）

解决方法：

- 重试：把要删除的缓存值或要更新的数据库值暂存到消息队列。如果删除缓存或更新数据库失败，从消息队列中重新读取，再次删除或更新

### 缓存雪崩

缓存雪崩是指缓存在**同一时刻大量缓存失效**，请求全部转发到数据库，数据库瞬时压力过大雪崩。比如缓存服务器宕机或者缓存过期。

**解决方案**

1. 将缓存失效时间分散开，比如在原有失效时间的基础上加上一个随机值
2. 服务降级

### 缓存击穿

缓存击穿是指**热点数据失效**，但是大量请求访问热点数据，导致请求打到了数据库而压力激增，影响数据库其他请求的处理。

**解决方案**

1. 对于热点数据不设置过期时间
2. 使用互斥锁，等操作返回成功将数据写入缓存。

### 缓存穿透

缓存穿透指的是**访问一个不存在的数据**，请求打在数据库上。

**解决方案**

1. 缓存控制或缺省值
2. 布隆过滤器
3. 请求入口前端进行请求合法性检测，过滤恶意请求

**布隆过滤器**

### 分布式锁

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。