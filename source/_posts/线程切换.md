---
title: 线程切换
date: 2021-03-19 00:45:41
categories: 操作系统
tags: 操作系统
---

&emsp;进程是操作系统的核心，通过进程基本可以将操作系统的所有知识联系起来。而线程是一种轻量级的线程，学习线程对学习进程是很有帮助的。

<!-- more -->

&emsp;首先我们思考一个问题：计算机运行为什么需要多线程呢？

- 首先，人们希望一个进程在同一时间不是执行一个任务。比如 QQ 在上传文件的同时，还需要确保能够正常聊天
- 其次，多线程让程序的结构变得简单。线程在有些场合可以帮助程序员以简单优雅的方式进程组织，并减少复杂度
- 最后，使用多线程可以实现并行运算，在多核 CPU 中可以加快处理的速度。

## user/kernel mode

&emsp;处理器有两种模式，一种是 user mode，第二种是 kernel mode。当运行在 kernel mode 时，CPU 可以运行**特权指令**（privileged instructions）；当运行在 user mode 时，CPU 只能运行普通指令，即**非特权指令**。

&emsp;普通指令指的是像 ADD、SUB、JRC、BRANCH 这样所有应用程序都允许执行的指令。而特权指令主要是一些直接操纵硬件的指令和设置保护的指令，比如设置 page table 寄存器、关闭时钟中断等。

&emsp;在处理器中有一个 flag 用来标志指令是否是特权指令。同时处理器中有一个 bit，用来标识是 user mode 还是 kernel mode。当处理器解析指令时，如果发现 user mode 尝试执行特权指令，处理器会拒绝执行这条指令。

&emsp;现在，我们知道当应用程序尝试执行特权指令时会被处理器拒绝掉，而且如果想要修改处理器中的 bit 位也需要执行特权指令，那么如何才能让应用程序执行内核才能执行的内核指令呢？

&emsp;如果用户空间尝试执行一条特权指令，用户程序会通过**系统调用**来切换到 kernel mode。当用户程序执行系统调用时，会通过 `syscall` 触发一个**软中断**（software interrupt），让程序陷入内核天。软中断会查询操作系统预先设定的**中断向量表**，并执行中断向量表中包含的**中断处理程序**。中断处理程序在内核中，这样就完成了 user mode 到 kernel mode 的切换，并执行用户程序想要执行的特权指令。

> ECALL 可以让应用程序将控制权转移给内核。它接收一个数字，岱庙应用程序想要调用的系统调用。

比如 ls 程序运行的时候，会调用 `read/write` 系统调用，Shell 程序会调用 fork 或者 exec 系统调用

## 线程模型

### 多对一模型

用户态进程的多线程复用一个内核线程，这样极大地减少了创建内核态线程的成本，但是线程不能并发。因此很少使用。

### 一对一模型

一对多模型是为每个用户态的线程分配一个单独的内核态线程。在这种情况下，每个用户态线程都需要通过系统调用创建一个绑定的内核线程。这种模型允许所有线程并发执行，能够充分利用多核优势，但是因为线程比较多，对内核调度的压力明显增加。

### 多对多模型

多对多模型会为 n 个用户态线程分配 m 个体内核态线程。m 通常小于 n，一般 m 为核数。这种关系减少了内核线程，同时保证了多核心并发

## 线程切换

假设我们有两个线程分别执行下面两段程序

```
100: A() {
	B();104:
}
200: B() {
	yield();204:
}
```

```
300: C() {
	D();304:
}
400: D() {
	yield();404:
}
```

我们做出如下规定：

- `100: A()` 表示 A 方法的地址为 400；
- `B();104:` 表示 B 方法返回的地址，即压入栈帧中的地址
- `yield()` 表示线程切换

所以，为了了解线程切换，我们只需要了解 `yield` 函数应该如何实现。为了方便说明，我们将上面的线程称之为线程 A，将下面的线程称之为线程 B。

### 用户线程之间切换

我们先来模拟一下函数的执行过程。

首先 A() 方法中调用 B() 方法，此时会将 B 方法的返回地址 104 压栈，然后执行 B 方法。B 方法调用 yield() 方法进行方法切换，将返回地址 204 压栈，然后执行 yield() 方法。

我们的目标是通过线程 A 的 yield() 方法，让线程 A 的 B() 方法跳转到线程 B 的 C() 方法中执行。我们初步可以实现下面这行代码

```
void yield() {
	找到 300;
	jmp 300;
}
```

我们现在继续模拟。程序跳转到 300:C() 方法后，将 D() 方法的地址 304 压栈，执行 D() 方法，然后调用 `yield()` 方法，将地址 404 压栈，切换到线程 A。

对于线程 B 的 yield() 方法，我们可以这样编写

```
void yield() {
	找到 204;
	jmp 204
}
```

现在栈的状态如下图所示

![image](https://cdn.jsdelivr.net/gh/crwen/img/blog/wrong_schedule.png)

线程 B 的 yield() 方法会跳到 204 执行，然后遇到右大括号，执行 `ret` 指令弹栈，回将栈顶的 404 弹栈，结果又回到了 D() 方法中，遇到右大括号，又回到 C() 方法中继续执行。这样就出现了问题。

为什么会产生问题呢？因为两个线程共用了一个栈。所以为了解决问题，每个线程都应该分配一个栈。当执行完 D() 中的 yield() 方法时，两个线程的线程栈应该处于如下状态

```
|104|  		|304|
|204|  		|404|
-----  		-----
```

此时我们执行线程 B 的 yield() 方法时需要切换线程栈，代码的大致流程如下

```
void yield() {
	TCB_B.esp = esp;
	esp = TCB_A.esp;
}
```

此时又轮到线程 A 执行，线程 A 遇到 B() 方法的右大括号，将 204 弹栈，回到 A() 方法，向下执行，接着弹栈。

由此我们可以得出一个结论，**每个线程都拥有一个栈，切换线程的时候线程栈也需要切换**。

光有线程栈还不够，我们还需要有一个设备存储当前线程执行指令的为止，方便执行下一条指令。这个设备叫做程序计数器。同时，我们还需要有一些寄存器，用来保存变量，以方便线程切换回来后可以准确地继续执行。以上这些信息都会存储到线程的 TCB 中，线程切换时，只需要切换线程的 TCB 即可。

通过上面内容，我们知道 TCB 中会包含如下内容：

- 程序计数器 PC，标识当前线程执行指令的为止
- 保存变量的寄存器
- 线程栈，记录函数调用的记录，并反映了当前线程的执行点

### 内核线程切换

通过上面对 user mode 和 kernel mode 的介绍，我们知道，如果想要使用特权指令，就需要使用系统调用，进入内核态，即需要从用户态线程切换到内核态线程。

如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的内核线程就会被激活。这个切换过程被称之为 上下文切换。在上下问切换前，我们需要保存线程上下文，即保存线程栈、寄存器等信息。之后 CPU 就会被切换到内核栈上运行，内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后返回用户空间时，又会使用之前保存的线程上下文来恢复用户线程状态。

如果我们需要从一个进程的线程切换到另一个进程的线程，那么我们需要先从进程的用户级线程切换到进程的内核级线程，再从进程的内核级线程切换到另一个进程的内核线程。之后在第二个进程的内核线程中返回到第二个进程的用户及线程。在这个切换中，在用户栈切换的同时，内核栈也跟着切换了。这个切换涉及到了进程的切换，所以还需要切换进程的映射表等信息。

【参考资料】

[MIT 操作系统](https://pdos.csail.mit.edu/6.828/2020/schedule.html)

[哈工大 操作系统 李治军](http://www.icourse163.org/course/HIT-1002531008)