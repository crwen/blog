---
title: 虚拟内存
date: 2021-03-18 01:39:16
categories: 操作系统
tags: 操作系统
---

什么是虚拟内存？维基百科是这样介绍的

> 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换

<!-- more -->

## 传统内存分配

在早些时期是没有虚拟内存这个概念的，那时候的计算机所访问的内存地址就是真实的物理地址。这样也许会很方便，但是这要求程序员清除地知道每一块内存是用来做什么的，这样难免会出现问题。

- **地址空间不隔离**：所有程序都可以直接访问物理地址，程序所使用的内存空间都是不隔离的。程序可以有意无意地修改其他程序的内存数据
- **内存使用效率低**：因为没有有效的内存管理机制，通常一个程序执行时，监控程序将整个程序装入内存中执行。如果内存不够用，就不能运行该程序。一个解决的办法是将其他程序写入磁盘，等到要用时再写回内存。这种情况下，程序需要的是连续的空间，所以换入换出的也是整个程序的空间，这样大量数据的换入换出效率是十分低下的。
- **程序运行的地址不确定**：因为程序每次装入时，我们都需要为其分配一块足够大的空间，而这个空闲空间是不确定的，当程序重定位时就会出现错误。

## 虚拟内存

有什么办法解决上面这些问题呢？我们知道，计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决（如果还不能解决就再添加一层.jpg）。所以，我们可以在程序与物理空间之间添加一层虚拟地址，让程序操作**虚拟地址**，让后将虚拟地址映射到真实的物理地址上。这个虚拟地址使得应用程序认为它拥有连续可用的内存，这个内存就是**虚拟内存**。顺便附上 IBM 关于虚拟的解释

>    它存在，你看得见，它是物理的
>
>    它存在，你看不见，它是透明的
>
>    它不存在，你看得见，它是虚拟的
>
>    它不存在，你看不见，它被删除

在任何时刻，虚拟内存的页面被分为三种：

- 未分配的：系统还没有分配的页，即没有任何数据与其关联，不占用磁盘空间
- 未缓存的：没有缓存在物理存储器中的已分配的页，即不再内存中的页
- 缓存的：当前缓存在物理存储器中的已分配的页，即在内存中的页

## 分段

### 基本思想

在编写程序时，我们倾向于从逻辑功能的角度去考虑，将程序分为多个逻辑功能段，每个段都有自己的段名与对应的段号，比如数据段、代码段、堆栈段等。在分配的时候都是以段位单位进行分配的，比如：

```assembly
LOAD 1，[D]|<A>
STORE 1，[X]|<B>
```

### 段表

每个段都对应一个段号，每个段的段号与段基址等信息形成了一个段表。CPU 在寻址的时候，会根据段号查询段表，找到每个段的段基址，然后加上段内偏移量得到需要访问的地址

![image](https://cdn.jsdelivr.net/gh/crwen/img/img/segment.png)

### 段保护

**越界中断处理**

进程在执行过程中，有时候需要扩大分段，比如数据段。由于要访问的地址超出原有的段长，所以会引发越界中断。操作系统处理中断时，首先判断该段的 “扩充位” 是否可扩充，如果可扩充，则增加段的长度，否则按出错处理。

**缺段中断处理**

检查内存中是否有足够的空闲空间

- 有，则装入该段，修改有关数据结构，中断返回
- 没有，检查内存中空闲区总和是否满足需求，如果满足，内存进行内存紧缩，否则淘汰一些段。

### 优缺点

分段的方法解决了上述第 1 和第 3 个问题，即地址空间不隔离问题和程序运行地址不确定问题。实际上这两个问题都是虚拟空间解决的问题。

但是分段并没有解决第二个问题，即内存使用效率问题。分段对内存区域的映射还是按照程序为单位的，如果内存不足，换入换出的依然是整个程序。

## 分页

实际上，根据程序局部性原理，当一个程序在运行时，在某个时间端内，它只是频繁地用到了一小部分数据，也就是说程序的很多数据在一个时间端内都是不会被用到的。所以我们可以使用更小粒度的内存分割和映射方法，提高内存的利用率。这种方法就是**分页**。

### 基本思想

分页的基本方法就是将地址空间等分为固定大小的页，物理内存也被分割为固定大小的页，每一页称之为**页框/页帧/物理块/内存块**。虚拟内存的每一页都会映射到对应的物理空间。这样我们就可以把常用的数据和代码页装入到内存中，把不常用的代码和数据换出到磁盘中。

### 页表

程序的每一个页都会映射到物理内存中的页框上，这是需要有一个表存储页号到页框号的映射，这个表就是**页表**，页表中的每一项称之为页表项。页表也是存放在内存中的，并且需要 CPU 中的一些寄存器存放页表在物理内存中的地址。当需要将一个虚拟地址转换为物理地址时，MMU 会自动查询页表，找到页面对应物理内存的页框号，这样就能够实现虚拟地址到物理地址的转换了。

每个进程都会有自己独立的页表，并且每个进程只能访问出现在自己页表中的物理内存。操作系统会设置页表，使得每个进程都拥有不重合的物理内存，这样一个程序就不能访问其他进程的物理内存了，因为其他进程的物理地址都不在它的页表中。

当操作系统刚启动时，会没有可用的页，操作系统会设置好内核使用的虚拟地址空间。当用户态进程创建时，内核会将内核页表复制到进程的页表中，所以所有的内核线程相当于都是使用的同一个内核页表。

### 多级页表

一个页一的大小一般为 4K。一个 32 为的机器的寻址能力为 32 位，这就说明 32 位机器的地址空间将有 2<sup>32</sup>/2<sup>12</sup>=2<sup>20</sup> 个页表项，那么将占用 4M（32bit * 2<sup>20</sup>）内存来存储页表项。这个代价太大了。

为了解决页表项过多的问题，引入了多级页表，即将页表项分为一级页表，一级页表有关联到二级页表，以此类推。这样就只需要 4K 的空间来存储页表了。

假设采用二级页表的方式，每一级页表使用 10 bit。那么 1 个页目录项可以关联到 2<sup>10</sup> 个地址空间，也就是说一个目录页可以关联到 2<sup>20</sup> 个地址空间。这时页表需要占用 2<sup>10</sup>*2<sup>10</sup> + 4K= 4.004M 的大小。这不是占用更大的内存了吗？这主要有两点原因

**1. 二级页表可以不存在**

实际上二级页表可以不存在。如果一级页表的页表项没有被用到，就不用创建这个页表项对应的二级页表了，即在需要时才创建二级页表。

那在不分级的页表中，如果页表项没有被用到，可不可以不创建呢？可以，但是不应该这样做。页表的职责时将虚拟地址翻译成物理地址，假如虚拟地址在页表中找不到对应的页表项，会发生错误，所以我们需要保证页表的寻址能力。那么我们能不能不将页表项顺序存放呢？如果不讲页表项顺序存放，我们每次访存的时候就需要遍历页表，这个操作带来的开销是十分巨大的。

**2. 二级页表可以不在主存中**

### 快表

在多级页表中，我们虽然节省了内存，但是却增加了访存的次数。假设使用二级页表，我们需要先从一级页表中找到目录项，然后再从二级页表中找到对应的页框号，最后，我们需要访问真实的物理内存，在一次寻址中我们进行了 3 次访问内存的操作。我们知道相对于 CPU 来说，访问内存是一个很慢的操作，所以如果有一个缓存能够缓存结果，那么将会大大提高效率。快表（Translation Lookside Buffer，TLB）就提供了这样的功能。

当进行了一次访存后，TLB 会记录虚拟地址到物理地址的映射。下次访问这个地址后，会从 TLB 中读取到对应的物理地址，直接进行访存。

## 段页式存储

段式存储方便了程序的管理，但是内存使用效率低下。页式存储虽然能够解决内存使用效率低下的问题，但是并不能方便程序的管理。一次人们将段式存储与页式存储相结合，这就是段页式存储了。

### 基本思想

段页式的基本思想是将程序分段，将段分页，这样既可以方便程序的编写，也可方便了内存的管理。

![image](https://cdn.jsdelivr.net/gh/crwen/img/blog/address.png)

【参考资料】

[程序员的自我修养](https://book.douban.com/subject/3652388/)

[MIT 操作系统](https://pdos.csail.mit.edu/6.828/2020/schedule.html)

[操作系统中的多级页表到底是为了解决什么问题](https://www.zhihu.com/question/63375062/answer/1403291487)