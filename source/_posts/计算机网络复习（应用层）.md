---
title: 计算机网络复习（应用层）
date: 2021-04-03 15:19:45
categories: 计算机网络
tags: 计算机网络
---

# 应用层

<!-- more -->

## DNS

DNS 是域名服务器，他提供了**主机名和 IP 地址之间相互转换**的服务。DNS 协议运行在 UDP 之上，使用 53 端口。

### 分层

DNS 服务器以层次方式组织，从上到下依次为根域名服务器、顶级域名服务器、权威域名服务器。上级服务器保存这子服务器的 IP 地址。

主机向本地域名服务器的查询一般都是采用递归查询（recursive query）。本地域名服务器向根域名服务器的查询通常采用迭代查询（iterative）

**递归查询**

当主机发出 DNS 请求时，该请求会被发送到本地 DNS 服务器。本地域名服务器起着一个代理作用，负责将 DNS 请求转发到 DNS 服务器层次结构中。

 如果主机所询问的本地域名服务器不知道被查询域名的IP地址, 本地域名服务器就会以DNS客户的身份, 向其他根域名服务器继续发出请求报文, (代替主机去查询, 不是主机自己去查询).

**迭代查询**

当用户发出一个查询请求时，会先从根服务器查询，返回一个顶级域名服务器的 IP。然后用户从顶级域名服务器中查询，返回一个权威域名服务器的 IP。最后从该权威域名服务器中查询 要查询域名的 IP 地址

DNS 服务器根据域名的层级，进行分级查询，从根域名开始，一次查询每一级域名，直到查到最终的 IP 地址

### 缓存

在一个请求链中，当某 DNS 服务器接收到一个 DNS 回答时，将其映射缓存在本地存储器中，下次查询时能够直接提供对应的 IP 地址。

为保持高速缓存中的内容的正确，域名服务器应为 每项内容设置计时器并处理超过合理时间的项（通常为2天）。当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。

本地 DNS 服务器也可以缓存 TLD 服务器的 IP 地址，因而允许本地 DNS 绕过查询链中的根 DNS 服务器。

不但在本地域名服务器中需要高速缓存，在主机中也很需要。许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。

### 查询过程

本地 host 文件 --> 本地缓存 --> 本地 DNS 服务器 递归查询 --> DNS 服务器迭代查询 

## HTTP

### 报文结构

HTTP 报文大致由三部分组成，即请求行/状态行、报文首部、报文实体。

#### 请求报文

请求报文结构：

- 请求行：第一行是包含了请求方法、URI、协议版本；
- 首部：接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 主体：最后是请求的内容主体

```html
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

#### 响应报文

响应报文结构：

- 相应行：第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 首部：接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 主体：最后是响应的内容主体

```html
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

#### 报文首部

##### 通用首部字段

|    首部字段名     |                    说明                    |
| :---------------: | :----------------------------------------: |
|   Cache-Control   |               控制缓存的行为               |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        |             创建报文的日期时间             |
|      Pragma       |                  报文指令                  |
|      Trailer      |             报文末端的首部一览             |
| Transfer-Encoding |         指定报文主体的传输编码方式         |
|      Upgrade      |               升级为其他协议               |
|        Via        |            代理服务器的相关信息            |
|      Warning      |                  错误通知                  |

##### 请求首部字段

|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|       Accept        |            用户代理可处理的媒体类型             |
|   Accept-Charset    |                  优先的字符集                   |
| **Accept-Encoding** |                 优先的内容编码                  |
|   Accept-Language   |             优先的语言（自然语言）              |
|    Authorization    |                  Web 认证信息                   |
|       Expect        |              期待服务器的特定行为               |
|        From         |               用户的电子邮箱地址                |
|      **Host**       |               请求资源所在服务器                |
|      If-Match       |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|    If-None-Match    |        比较实体标记（与 If-Match 相反）         |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|    Max-Forwards     |                 最大传输逐跳数                  |
| Proxy-Authorization |         代理服务器要求客户端的认证信息          |
|        Range        |               实体的字节范围请求                |
|       Referer       |            对请求中 URI 的原始获取方            |
|         TE          |                传输编码的优先级                 |
|     User-Agent      |              HTTP 客户端程序的信息              |

##### 响应首部字段

|     首部字段名     |             说明             |
| :----------------: | :--------------------------: |
|   Accept-Ranges    |     是否接受字节范围请求     |
|        Age         |     推算资源创建经过时间     |
|        ETag        |        资源的匹配信息        |
|      Location      |   令客户端重定向至指定 URI   |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
|    Retry-After     |   对再次发起请求的时机要求   |
|       Server       |    HTTP 服务器的安装信息     |
|        Vary        |   代理服务器缓存的管理信息   |
|  WWW-Authenticate  |   服务器对客户端的认证信息   |

##### 实体首部字段

|    首部字段名    |          说明          |
| :--------------: | :--------------------: |
|      Allow       | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language |   实体主体的自然语言   |
|  Content-Length  |     实体主体的大小     |
| Content-Location |   替代对应资源的 URI   |
|   Content-MD5    |   实体主体的报文摘要   |
|  Content-Range   |   实体主体的位置范围   |
|   Content-Type   |   实体主体的媒体类型   |
|     Expires      | 实体主体过期的日期时间 |
|  Last-Modified   | 资源的最后修改日期时间 |

### HTTP 方法

客户端发送的 请求报文 第一行为请求行，包含了方法字段

- **GET**：获取资源
- **HEAD**：获取报文首部，但是不包含报文实体
- **POST**：传输实体，主要用来传输数据
- **PUT**：传输文件，报文主题包含文件内容。不带验证机制，所有人都能上传，存在安全问题
- **PATCH**：对资源进行部分修改
- **DELETE**：删除文件，与 PUT 一样不带验证机制
- **OPTIONS**：询问支持的方法，返回支持的 HTTP 方法
- **TRACE**：追踪路径。返回通信路径，容易收到 XST(跨站追踪) 攻击
- **CONNECT**：要求在与代理服务器通信时建立隧道

**GET 与 POST 区别**

- 作用：GET 请求主要用于获取资源，POST 请求主要用于传输实体
- 参数：GET 的参数是以字符串的形式出现在 URL 中的，而 POST 的参数是存储再实体主体中
- 安全：GET 方法是安全的，而 POST 不是安全的。因为 POST 可能会修改服务器的状态
- 幂等性：GET 是幂等的，POST 不是幂等的

> 安全的 HTTP 方法不会改变服务器状态，也就是说它是制度的
> 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。

### 状态码

- **100 Continue**：到目前为止正常

**2XX**

- **200 OK**
- **204 No Content**：消息成功处理，但是返回的响应报文不包含实体部分
- **206 Partial Content**：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

**3XX 重定向**

- **301 Moved Permanently**：永久重定向
- **302 Found**：临时重定向
- **303 See Other**：临时重定向，要求客户端采用 GET 获取资源
- **304 Not Modified**：请求报文首部包含条件(if-Match、if-Modified-Since...)，但是条件不满足
- **307 Temporary Redirect**：临时重定向，要求浏览器不会POST 改成 GET

**4XX 客户端错误**

- **400 Bad Request**：请求报文中存在语法错误
- **401 Unauthorized**：当前请求需要用户验证或认证失败
- **403 Forbidden**：请求被拒绝
- **404 Not Found**：请求希望得到的资源未在服务器上发现
- **405 Method Not Allowed**：请求行中指定的请求方法不能被用于请求相应资源

**5XX 服务器错误**

- **500 Internal Server Error**：，服务器执行请求时发生错误
- **502 Bad Gateway**： 网关或代理服务器尝试执行请求时接收到无效响应。一般是服务器过载
- **503 Service Unavailable**：，服务器临时过载或正在维护，现在无法处理请求
- **504 Gateway Timeout**： 网关或代理服务器尝试执行请求时未能及时接收到响应。

### 连接管理

#### 长连接与短链接

HTTP 请求时建立在 TCP 连接之上的，而 TCP 连接分为长连接和短链接

**短连接**

短链接是指对于每一个 HTTP 请求都建立一个连接，传输完数据后断开连接。

HTTP/1.0 中默认使用短链接

**长连接**

长连接是指发送 HTTP 请求时先建立一个 TCP 连接，请求发送完毕后先不关闭 TCP 连接，之后的 HTTP 请求可以复用这个 TCP 连接。

**keep-alive**

keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。

#### Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是服务器发送到用户**浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

**用途：**

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

**创建过程**

1. 服务器发送的响应报文包含 **Set-Cookie** 首部字段，客户端得到响应报文后将 Cookie 内容保持到浏览器
2. 客户端对服务器发送请求时，从浏览器提取 Cookie 发送给浏览器

#### Session

当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。

如果浏览器禁用 cookie，可以在 URL 中携带 sessionId

#### 请求过程

**1.解析 URL**

```	html
http://www.baidu.com :80  /file1.html? user=1
协议   Web 服务器域名  端口 数据源路径		参数
```

**2. DNS 查询域名**

本地 host 文件 --> 本地缓存 --> 本地 DNS 服务器 递归查询 --> DNS 服务器迭代查询 

**3. 建立 TCP 连接**

**4. 发送 HTTP 请求**

**5. 网卡收到网络包，将电信号转换为数字信号，交给上层**

报头的波形同步时钟，起始帧分界符，MAU 模块，MAC 模块，检查 FCS，检查 MAC 地址，通知知计算机收到一个包

报文的波形同步时钟，然后遇到起始帧分界符时，开始将后面的信号转换为数字信号。

MAU 模块会将信号转换成通用格式并发送给 MAC 模块，MAC 模块再从头开始将信号转换为数字信号，并存放在缓冲区中。

当到达信号末尾时，检查 FCS， 出错，丢弃。

检查 MAC 头部中介绍放的 MAC 地址与网卡的 MAC 地址是否一致。不一致，丢弃，否则将包放在缓冲区。

网卡向扩展总线中的中断信号发送中断信号（硬件的中断号和相应的驱动程序绑定），中断程序从缓冲区中读取数据。

IP 模块检查数据包接受方的 IP 地址是否本机 IP 地址，不是，发送 ICMP 报文通知错误

TCP 模块找到对应的套接字，放入缓冲区，等待应用层读取数据

**5. 服务端处理请求，并响应**

**5.浏览器得到响应，解析信息**

一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。“推测性解析”，“解析” 是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。

**6. 渲染**

渲染步骤包括**样式、布局、绘制**，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

**上面过程所有请求到达主机前都会经过 ARP 将 IP 转化为 MAC 地址的过程**

### HTTP 版本

#### HTTP 1.x

- 基于 TCP
- **队头阻塞**，每个 TCP 连接同时只能处理一个请求-响应。如果上一个响应没有返回，后续请求-响应都会阻塞。队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。
  - 域名分片，将同一页面资源分散到不同域名下
- 浏览器最多同时处理 6~8 个 TCP 连接
- **明文传输**：不安全

**HTTP 1.0**：

- 默认使用短连接，每次请求都需要重新建立一次连接

**HTTP 1.1**

- 默认使用长连接，减少 TCP 建立连接耗费的时间
- 支持请求流水线 Pipeline，客户端收到 HTTP 响应报文之前就能接着发送新的请求报文。通过建立多个连接来实现
- 支持断点续传，返回 206(Partial Content)

#### HTTP 2.0

- **头部压缩**：使用 HPACK 算法，每次请求和响应只发送差异头部，一般可以达到 50%~90% 的高压缩率。
- 采用**多路复用技术**，将报文以二进制的形式编码，同时将其分成多个帧，叫做**二进制帧**。同一个请求的二进制帧带有相同的标识，供接收方将其拼凑成一个完整的报文
- 队头阻塞：客户端无需等待一个请求完成就可以发送另一个请求。但是如果网络中有一个数据包丢失或网络中断，整个 TCP 连接就会暂停。
- 同一域名下的所有请求建立在一个 TCP 连接上

**缺陷：**

- 如果传输中发生数据丢包，即使丢失的数据仅涉及单个请求，所有请求和响应也同样会受到数据包丢失的影响而需要重传。因为尽管 HTTP/2 可以在不同的流上隔离不同的 HTTP 交换，但是底层的 TCP 并无法对他们进行区别，TCP 能看到的只是没有任何标志的字节流。
- 多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。

**二进制帧**

帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的消息被分为更小的数据帧

**多路复用**

多路复用通常表示在一个信道上传输**多路**信号或数据流的过程和技术。

在一个 TCP 连接上，可以向对方不断发送帧，每帧的 stream identifier 都标明这一帧属于哪个流。接收方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。

流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题

- 同域名下所有通信都在单个连接上完成
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息由一个或多个帧组成，多个帧之间可以乱序发送，以标识符重连。

#### HTTP 3.0

- 基于 TCP，使用 QUIC（quick udp internet connection）
- 无需等待应答，一旦建立连接，只管数据的发送

##### QUIC

在已建立的连接上，双方均可以建立传输给对方的数据流。单一数据流的传输是可靠、有序的，但不同的数据流间可能无序传送。

举个例子：服务器传送流 A 和 B 到客户端。流 A 先启动，然后是流 B。在 QUIC 中，丢包只会影响该包所处的流。如果流 A 发生了一次丢包，而流 B 没有，流 B 将继续传输直到结束，而流 A 将会进行丢包重传过程。

**连接迁移**

每个连接过程都有一组连接标识符，称为连接 ID，用来识别该连接，确保底层协议的寻址变更不会使 QUIC 连接传输数据到错误的端点。这样连接可以在 IP 地址和网络接口迁移的情况下得到保持。

**流量控制**

每个数据流都有独立的流量控制，端点可以通过此实现内存控制和反压。

**流标识符**

数据流通过一个无符号的 62 bit 标识，也称 ID 流。流 ID 最低 2 位用于流类型（单向、双向）和流的发起者。最低一位用于标识流的发起者，客户端发起双数为 0，服务端发起单数为 1。第二个 bit 识别 单/双向流。

**流并发**

QUIC 允许任意数量的并发流。端点通过闲置最大流 ID 来控制并发活动的传入流数量。每个端点指定自己的最大流 ID 数，并值对对等端端点有效

**收发数据**



**快速握手**

QUIC 提供 0-RTT 和 1-RTT 的连接建立，这意味着 QUIC 在最佳情况下不需要任何的额外往返时间便可建立新连接。其中更快的 0-RTT 仅在两个主机之间建立过连接且缓存了该连接的 “秘密”（secret）时可以使用。



## HTTPs

HTTPS 是以安全为目标的 HTTP 通道，它在 HTTP 中加入 SSL 层以提高数据传输的安全性。

HTTP 被用于在 Web 浏览器和网站服务器之间传递信息，但以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此 HTTP 不适合传输一些敏感信息，比如身份证号码、密码等。

为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并对浏览器和服务器之间的通信进行数据加密，以保障数据传输的安全性，

### 加密算法

**1. 对称加密**

**对称加密加密和解密都使用同一个密钥**。常见的有 DES、DES3、AES 等

优点：加密速度快、效率高，适合加密比较大的数据

缺点：

- 安全性：密钥在传输过程中可能被截获
- 密钥管理：每次使用对称加密算法时，都需要使用他人不知道的唯一密钥，这回使得收发信双方用用密钥数量急剧增长

**2. 非对称加密**

**非对称加密加密和解密使用不同的密钥**，使用公钥加密，私钥解密。常见的有 RSA

通信双方分别生成公钥和私钥，然后交换公钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

- 优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。
- 缺点：计算量比较大，加密和解密速度相比对称加密慢很多。

**3. HTTPS 采用的加密方式**

上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此可以利用非对称密钥加密方式将密钥传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

- 使用非对称加密方式，传输对称加密方式所需要的 Secret Key，从而保证安全性；
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

### 签名算法

在非对称加密中，通信双方分别生成公钥和私钥，并相互交换公钥。通信时使用公钥加密，私钥解密。就算中间人截获了消息和公钥，也无法解密。虽然中间人无法解密消息，但是中间人截获了公钥也可以发送消息，所以非对称加密无法防止消息的伪造和篡改。而对于接收者来说，无法分辨出邮件是由谁发送的。

使用数字签名能够鉴别消息的发送者，让中间人无法伪造或篡改数据进行发送。发送者先用 Hash 函数，生成消息摘要，然后使用私钥对这个摘要加密，生成数字签名，并附在消息中一起发送给接收方。接收方接收到消息后，取出数字签名，使用公钥验签，证实消息的发送者。然后对消息使用相同的 Hash 算法，对比摘要是否相同。

### CA 认证

如果中间人将自己的公钥冒充发通信一方 A 的公钥发送给另一方 B，然后 B 保存了下来，那么以后 A 发送个 B 的消息验证签名都会失败。

![伪造公钥](https://segmentfault.com/img/remote/1460000024523784)

为了证明 B 是 B，引入了一个第三方的证书认证中心，CA。CA 用自己的私钥对申请者的公钥和一些相关信息一起加密，生成数字证书。

### **数字证书**

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

证书包含证书的颁发机构、持有者、签名算法、公钥、加密算法、Hash 算法、证书到期时间等信息。

A 收到 B 的数字证书后，A 使用 CA 的公钥进行验证，验证通过即可以证明 这是 B 发送的消息。然后使用私钥解密

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

### SSL/TLS

TLS 由若干不同职责的模块组成，比较常见的由握手协议、变更密码规范协议、镜报协议和记录协议等。

<img src="https://upload-images.jianshu.io/upload_images/2573196-14bab45e133d24e6.png" alt="img" style="zoom:50%;" />

从体系结构图可以看出，SSL/TLS 协议可分为两层：握手协议和记录协议

- 握手协议：握手协议用来协商会话参数，建立在 SSL 记录协议之上，用于在实际传输数据之前，通信双方进行身份认证、协商加密算法、交换会话密钥
- 记录协议：建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩及加密等基本功能支持。

### 连接过程

1. **建立 TCP 连接**：客户端通过 TCP 和服务器建立连接
2. **发起请求**：发送一个请求证书给服务端，在该请求消息里包含一个随机数、支持的加密算法列表等信息
3. **证书返回**：服务端收到消息后回应客户端，响应包括数字证书、加密算法、“server random” 随机数等信息
4. **证书验证**：客户端收到证书后，验证证书签发机构，并使用该签发机构的公钥确认签名是否有效，验证证书中域名是否是连接的域名。如果证书有效，生成一个"premaster secret" 随机数，并使用公钥加密，发送给服务端。
5. **密钥交换**：服务端接收后使用私钥解密，利用 client random、server random、premaster secret 和一定的算法生成对称密钥，发送给客户端
6. **数据传输**：客户端和客服端进行使用对称密钥进行数据传输

### HTTP 与 HTTPs 区别

- HTTP 使用 80 端口，HTTPs 使用 443 端口
- HTTP 效率比 HTTPs 更高，HTTPs 加密会浪费时间并且会增加密钥交换的网络开销
- HTTPs 更加安全